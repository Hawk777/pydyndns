#!/usr/bin/env python3

import abc
import argparse
import json
import logging
import logging.config
import logging.handlers
import netifaces
import os
import socket
import sys

import dns.name
import dns.rdataclass
import dns.rdatatype
import dns.rdtypes.IN.A
import dns.rdtypes.IN.AAAA
import dns.resolver
import dns.update


class Family(metaclass=abc.ABCMeta):
    """
    Encapsulates knowledge about a specific address family.
    """

    @abc.abstractmethod
    def getName(self):
        """Return the name used as a cache key for addresses in this family."""
        pass

    @abc.abstractmethod
    def getNetIFacesConstant(self):
        """Return the numeric ID used as a key in netifaces’ output."""
        pass

    @abc.abstractmethod
    def addAddressToUpdate(self, update, hostPart, ttl, address):
        """Add an address in this family to a DNS update request."""
        pass

    @abc.abstractmethod
    def filterAddressList(self, addresses):
        """
        Return only those addresses that are useful, e.g. not loopback,
        link-local, temporary, or other special addresses that should not be
        registered.
        """
        pass


class IPv4(Family):
    def getName(self):
        return "ipv4"

    def getNetIFacesConstant(self):
        return netifaces.AF_INET

    def addAddressToUpdate(self, update, hostPart, ttl, address):
        update.add(hostPart, ttl, dns.rdtypes.IN.A.A(dns.rdataclass.IN, dns.rdatatype.A, address))

    def filterAddressList(self, addresses):
        # For IPv4 most NICs have only one address. It’s not clear that there
        # are any specific rules about how multiple addresses ought to be
        # handled. Just include all of them that are acceptable.
        return [x for x in addresses if self.includeAddress(x)]

    def includeAddress(self, address):
        parts = [int(part) for part in address.split(".")]
        if parts[0] == 127:
            return False # Loopback address
        elif parts[0] >= 240:
            return False # Multicast or reserved address
        return True


class IPv6(Family):
    def __init__(self, config):
        self._config = config

    def getName(self):
        return "ipv6"

    def getNetIFacesConstant(self):
        return netifaces.AF_INET6

    def addAddressToUpdate(self, update, hostPart, ttl, address):
        update.add(hostPart, ttl, dns.rdtypes.IN.AAAA.AAAA(dns.rdataclass.IN, dns.rdatatype.AAAA, address))

    def filterAddressList(self, addresses):
        # For IPv6, most NICs will have multiple addresses: one permanent and a
        # bunch of temporary generated by SLAAC privacy extensions. We should
        # include only the permanent address, not the temporary ones.
        # Unfortunately those addresses cannot be distinguished by address
        # alone, nor does netifaces give any further metadata that would allow
        # distinguishing them. However, Windows appears to always return its
        # permanent address first in the list, while Linux appears to always
        # return its permanent address last in the list.
        acceptable = [x for x in addresses if self.includeAddress(x)]
        if len(acceptable) == 0:
            return []
        if os.name == "posix":
            # Assume Linux, or hopefully other Linux-like platforms behave the
            # same.
            return [acceptable[-1]]
        elif os.name == "nt":
            # Windows.
            return [acceptable[0]]
        else:
            # No clue what platform. Just use all addresses.
            return acceptable

    def includeAddress(self, address):
        first_word = int(address.split(":")[0] or "0", 16)
        second_word = int(address.split(":")[1] or "0", 16)
        if first_word == 0x0000:
            return False # Unspecified, local, or IPv6-mapped address
        elif first_word == 0x0100:
            return False # Discard address
        elif (first_word & 0xFE00) == 0xFC00:
            return False # Unique local address
        elif first_word == 0xFE80:
            return False # Link-local address
        elif (first_word & 0xFF00) == 0xFF00:
            return False # Multicast address
        elif ((first_word == 0x2001) and (second_word == 0x0000)) and not self._config["teredo"]:
            return False # Teredo address
        return True


def run(args, config, logger):
    # Decide which families to use.
    families = []
    if config["ipv4"]:
        families.append(IPv4())
    if config["ipv6"]["enable"]:
        families.append(IPv6(config["ipv6"]))
    if not families:
        logger.error("No address families are enabled.")
        return

    # Grab the TTL from the config file.
    ttl = int(config["ttl"])

    # Load the cache file, if any.
    if "cache" in config:
        try:
            with open(config["cache"], "r") as cacheFile:
                cache = json.load(cacheFile)
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            cache = None
    else:
        cache = None

    # Rip apart my hostname.
    fqdn = dns.name.from_text(socket.getfqdn())
    zone = fqdn.parent()
    hostPart = fqdn.relativize(zone)

    # Find which nameserver we should talk to using an SOA query.
    resp = dns.resolver.query(zone, dns.rdatatype.SOA)
    if len(resp.rrset) != 1:
        raise RuntimeError("Got {} SOA records for zone {}, expected 1.".format(len(resp.rrset), zone))
    server = resp.rrset[0].mname.to_text(omit_final_dot=True)
    logger.debug("Using nameserver {}.".format(server))

    # Find my addresses.
    addresses = {family.getName(): [] for family in families}
    for interface in (args.interface or netifaces.interfaces()):
        for family in families:
            ifAddresses = netifaces.ifaddresses(interface).get(family.getNetIFacesConstant(), [])
            addresses[family.getName()] += family.filterAddressList([addr["addr"] for addr in ifAddresses])
    for family in families:
        addresses[family.getName()].sort()

    # Get the hostname and addresses most recently sent from the cache.
    if cache:
        last_hostname = cache.get("hostname")
        last_addresses = cache.get("addresses")
    else:
        last_hostname = None
        last_addresses = None

    # Check if the current hostname and addresses are the same as the last one.
    if fqdn.to_text() == last_hostname and addresses == last_addresses and not args.force:
        logger.info("Eliding DNS record update for {} to {} as cache says addresses have not changed.".format(fqdn, addresses))
    else:
        # Issue the update.
        logger.info("Updating DNS record for {} to {}.".format(fqdn, addresses))
        update = dns.update.Update(zone)
        update.delete(hostPart)
        for family in families:
            for address in addresses[family.getName()]:
                family.addAddressToUpdate(update, hostPart, ttl, address)
        resp = dns.query.tcp(update, server)
        if resp.rcode() != dns.rcode.NOERROR:
            raise RuntimeError("Update failed with rcode {}.".format(resp.rcode()))

        # Update the cache to remember that we did this.
        if "cache" in config:
            with open(config["cache"], "w") as cacheFile:
                json.dump({"hostname": fqdn.to_text(), "addresses": addresses}, cacheFile, ensure_ascii=False, allow_nan=False)


if __name__ == "__main__":
    # Parse command-line arguments.
    parser = argparse.ArgumentParser(description="Dynamically update DNS records.")
    parser.add_argument("-c", "--config", default="/etc/pydyndns.conf", type=str, help="which configuration file to read (default: /etc/pydyndns.conf)", metavar="FILE")
    parser.add_argument("-f", "--force", action="store_true", help="update even if cache says unnecessary")
    parser.add_argument("interface", nargs="*", help="the name of an interface whose address(es) to register (default: all interfaces)")
    args = parser.parse_args()

    # Load configuration file.
    with open(args.config, "r") as configFile:
        config = json.load(configFile)

    # Configure logging.
    if "logging" in config:
        logging.config.dictConfig(config["logging"])
    else:
        logging.basicConfig(level=logging.DEBUG)
        logging.warn("No logging section in config file.")

    # Run the program.
    try:
        run(args, config, logging.getLogger("pydyndns"))
    except (KeyboardInterrupt, SystemExit):
        raise
    except:
        logging.getLogger("pydyndns").error("Unhandled exception", exc_info=True)
