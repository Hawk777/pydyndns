#!/usr/bin/env python3

import logging
import logging.handlers
import netifaces
import os
import socket
import subprocess
import sys

import dns.name
import dns.rdataclass
import dns.rdatatype
import dns.rdtypes.IN.AAAA
import dns.resolver
import dns.update


def is_global(addr):
    first_word = int(addr.split(":")[0] or "0", 16)
    if first_word == 0x0000:
        return False # Unspecified, local, or IPv6-mapped address
    elif first_word == 0x0100:
        return False # Discard address
    elif (first_word & 0xFE00) == 0xFC00:
        return False # Unique local address
    elif first_word == 0xFE80:
        return False # Link-local address
    elif (first_word & 0xFF00) == 0xFF00:
        return False # Multicast address
    return True


if __name__ == "__main__":
    try:
        # Configure logging.
        logging.basicConfig(level=logging.DEBUG, handlers=[logging.handlers.SysLogHandler(address="/dev/log", facility=logging.handlers.SysLogHandler.LOG_LOCAL0)])

        # Rip apart my hostname.
        fqdn = dns.name.from_text(socket.getfqdn())
        zone = fqdn.parent()
        hostPart = fqdn.relativize(zone)

        # Find which nameserver we should talk to using an SOA query.
        resp = dns.resolver.query(zone, dns.rdatatype.SOA)
        if len(resp.rrset) != 1:
            raise RuntimeError("Got {} SOA records for zone {}, expected 1.".format(len(resp.rrset), zone))
        server = resp.rrset[0].mname.to_text(omit_final_dot=True)
        logging.debug("Using nameserver {}.".format(server))

        # Find my address.
        addresses = netifaces.ifaddresses(sys.argv[1])[netifaces.AF_INET6]
        addresses = [addr["addr"] for addr in addresses if is_global(addr["addr"])]
        if len(addresses) == 0:
            logging.warn("No IPv6 addresses on interface {}.".format(sys.argv[1]))
            address = None
        elif len(addresses) == 1:
            address = addresses[0]
        else:
            logging.warning("Multiple IPv6 addresses on interface {}: {}".format(sys.argv[1], addresses))
            address = addresses[0]

        # Get the hostname and address most recently sent from the cache file.
        try:
            with open("/run/pydyndns") as fp:
                last_hostname = fp.readline().rstrip("\n")
                last_address = fp.readline().rstrip("\n")
        except:
            last_hostname = None
            last_address = None

        # Check if the current hostname and address are the same as the last
        # one.
        if fqdn.to_text() == last_hostname and address == last_address:
            logging.info("Eliding DNS record update for {} to {} as cache says address has not changed.".format(fqdn, address))
        else:
            # Issue the update.
            logging.info("Updating DNS record for {} to {}.".format(fqdn, address))
            update = dns.update.Update(zone)
            update.delete(hostPart)
            update.add(hostPart, 300, dns.rdtypes.IN.AAAA.AAAA(dns.rdataclass.IN, dns.rdatatype.AAAA, address))
            resp = dns.query.tcp(update, server)
            if resp.rcode() != dns.rcode.NOERROR:
                raise RuntimeError("Update failed with rcode {}.".format(resp.rcode()))

            # Update the cache to remember that we did this.
            with open("/run/pydyndns", "w") as fp:
                fp.write(fqdn.to_text())
                fp.write("\n")
                fp.write(address)
                fp.write("\n")
    except:
        logging.error("Unhandled exception", exc_info=True)
