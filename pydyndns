#!/usr/bin/env python3

import abc
import argparse
import json
import logging
import logging.config
import logging.handlers
import netifaces
import socket
import sys

import dns.name
import dns.rdataclass
import dns.rdatatype
import dns.rdtypes.IN.A
import dns.rdtypes.IN.AAAA
import dns.resolver
import dns.update


class Family(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def getName(self):
        pass

    @abc.abstractmethod
    def getNetIFacesConstant(self):
        pass

    @abc.abstractmethod
    def addAddressToUpdate(self, update, hostPart, ttl, address):
        pass

    @abc.abstractmethod
    def filterAddressList(self, addresses):
        pass


class IPv4(Family):
    def getName(self):
        return "ipv4"

    def getNetIFacesConstant(self):
        return netifaces.AF_INET

    def addAddressToUpdate(self, update, hostPart, ttl, address):
        update.add(hostPart, ttl, dns.rdtypes.IN.A.A(dns.rdataclass.IN, dns.rdatatype.A, address))

    def filterAddressList(self, addresses):
        return [x for x in addresses if self.includeAddress(x)]

    def includeAddress(self, address):
        parts = [int(part) for part in address.split(".")]
        if parts[0] == 127:
            return False # Loopback address
        elif parts[0] >= 240:
            return False # Multicast or reserved address
        return True


class IPv6(Family):
    def getName(self):
        return "ipv6"

    def getNetIFacesConstant(self):
        return netifaces.AF_INET6

    def addAddressToUpdate(self, update, hostPart, ttl, address):
        update.add(hostPart, ttl, dns.rdtypes.IN.AAAA.AAAA(dns.rdataclass.IN, dns.rdatatype.AAAA, address))

    def filterAddressList(self, addresses):
        return [x for x in addresses if self.includeAddress(x)]

    def includeAddress(self, address):
        first_word = int(address.split(":")[0] or "0", 16)
        if first_word == 0x0000:
            return False # Unspecified, local, or IPv6-mapped address
        elif first_word == 0x0100:
            return False # Discard address
        elif (first_word & 0xFE00) == 0xFC00:
            return False # Unique local address
        elif first_word == 0xFE80:
            return False # Link-local address
        elif (first_word & 0xFF00) == 0xFF00:
            return False # Multicast address
        return True


def run(interface, config, logger):
    # Decide which families to use.
    families = []
    if config["ipv4"]:
        families.append(IPv4())
    if config["ipv6"]:
        families.append(IPv6())
    if not families:
        logger.error("No address families are enabled.")
        return

    # Grab the TTL from the config file.
    ttl = int(config["ttl"])

    # Load the cache file, if any.
    if "cache" in config:
        try:
            with open(config["cache"], "r") as cacheFile:
                cache = json.load(cacheFile)
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            cache = None
    else:
        cache = None

    # Rip apart my hostname.
    fqdn = dns.name.from_text(socket.getfqdn())
    zone = fqdn.parent()
    hostPart = fqdn.relativize(zone)

    # Find which nameserver we should talk to using an SOA query.
    resp = dns.resolver.query(zone, dns.rdatatype.SOA)
    if len(resp.rrset) != 1:
        raise RuntimeError("Got {} SOA records for zone {}, expected 1.".format(len(resp.rrset), zone))
    server = resp.rrset[0].mname.to_text(omit_final_dot=True)
    logger.debug("Using nameserver {}.".format(server))

    # Find my addresses.
    addresses = {family.getName(): [] for family in families}
    for interface in (args.interface or netifaces.interfaces()):
        for family in families:
            ifAddresses = netifaces.ifaddresses(interface).get(family.getNetIFacesConstant(), [])
            addresses[family.getName()] += family.filterAddressList([addr["addr"] for addr in ifAddresses])
    for family in families:
        addresses[family.getName()].sort()

    # Get the hostname and addresses most recently sent from the cache.
    if cache:
        last_hostname = cache.get("hostname")
        last_addresses = cache.get("addresses")
    else:
        last_hostname = None
        last_addresses = None

    # Check if the current hostname and addresses are the same as the last one.
    if fqdn.to_text() == last_hostname and addresses == last_addresses:
        logger.info("Eliding DNS record update for {} to {} as cache says addresses have not changed.".format(fqdn, addresses))
    else:
        # Issue the update.
        logger.info("Updating DNS record for {} to {}.".format(fqdn, addresses))
        update = dns.update.Update(zone)
        update.delete(hostPart)
        for family in families:
            for address in addresses[family.getName()]:
                family.addAddressToUpdate(update, hostPart, ttl, address)
        resp = dns.query.tcp(update, server)
        if resp.rcode() != dns.rcode.NOERROR:
            raise RuntimeError("Update failed with rcode {}.".format(resp.rcode()))

        # Update the cache to remember that we did this.
        if "cache" in config:
            with open(config["cache"], "w") as cacheFile:
                json.dump({"hostname": fqdn.to_text(), "addresses": addresses}, cacheFile, ensure_ascii=False, allow_nan=False)


if __name__ == "__main__":
    # Parse command-line arguments.
    parser = argparse.ArgumentParser(description="Dynamically update DNS records.")
    parser.add_argument("-c", "--config", default="/etc/pydyndns.conf", type=str, help="which configuration file to read (default: /etc/pydyndns.conf)", metavar="FILE")
    parser.add_argument("interface", nargs="*", help="the name of an interface whose address(es) to register (default: all interfaces)")
    args = parser.parse_args()

    # Load configuration file.
    with open(args.config, "r") as configFile:
        config = json.load(configFile)

    # Configure logging.
    if "logging" in config:
        logging.config.dictConfig(config["logging"])
    else:
        logging.basicConfig(level=logging.DEBUG)
        logging.warn("No logging section in config file.")

    # Run the program.
    try:
        run(args.interface, config, logging.getLogger("pydyndns"))
    except (KeyboardInterrupt, SystemExit):
        raise
    except:
        logging.getLogger("pydyndns").error("Unhandled exception", exc_info=True)
